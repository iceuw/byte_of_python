# 更多

到目前为止，我们已经涵盖了您将使用的Python各个方面的大部分。在这一章，我们将介绍使我们的Python知识更全面的更多方面。

## Passing tuples around 

你是否一直希望可以从一个函数返回两个不同的值？你可以，你所要做的就是使用一个元组。

~~~
>>> def get_error_details():
...     return (2, '第2个错误的细节')
...
>>> errnum, errstr = get_error_details()
>>> errnum
2
>>> errstr
'第2个错误的细节'
~~~

注意，`a, b = <some expression>`的用法是表示将表达式的结果作为一个有两个值的元组。

如果你想将结果解释为`(a, <其它的一切>)`，那么你只需要以星号开始，就像你在函数参数中做的：

~~~
>>> a, *b = [1, 2, 3, 4]
>>> a
1
>>> b
[2, 3, 4]
~~~

这也意味着，在Python中以最快的方式交换两个变量是:

~~~
>>> a = 5; b = 8
>>> a, b = b, a
>>> a, b
(8, 5)
~~~

## 特别的方法 

有一些特别的方法，比如`__init__`和`__del__`方法在类中有特殊意义。

特殊的方法用于模拟内置类型的某些行为，例如，如果您想要使用`x[key]`索引操作你的类(就像你用在列表和元组中使用的)，那么你所要做的就是实现`__getitem__()`的方法，做你的工作。如果你仔细想想，这就是Python为`list`类本身所做的!

在下面的表中列出了一些有用的特别的方法。如果你想知道所有的特殊方法，[参见手册](http://docs.python.org/py3k/reference/datamodel.html#specialnames)。

`__init__(self, ...)`

:   这个方法在新创建对象返回用法之前被调用。

`__del__(self)`

:   在对象被销毁前调用

`__str__(self)`

:   当使用`print`函数或`str()`函数时调用。

`__lt__(self, other)`

:   当使用*小于*(&lt;)操作符时调用，同样的，所有的操作符(+, &gt;,等。)都有特别的方法。

`__getitem__(self, key)`

:   当使用`x[key]`索引操作时调用。

`__len__(self)`

:   当序列对象的内建`len()`函数使用时调用。

## 单语句块 

我们已经看到,每个块语句以它自己的缩进级别与其它部分分离。嗯，有一个警告。如果你的块语句只包含一个单独的语句，那么您可以指定在同一行，例如，一个条件语句和循环语句。下面的示例应该清楚地说明这一点:

~~~
>>> flag = True
>>> if flag: print('是的')
是的
~~~

请注意，单个语句用于原地而不是作为一个单独的块。虽然，你这可以让你的程序*较小*，我强烈建议避免这种简化方法，除非是错误检查，主要因为如果你正在使用适当的缩进，它会更容易添加一个额外的声明。

## Lambda 形式 

一个`lambda`语句是用来创建新的函数对象。从本质上讲，`lambda`取得一个参数，后面有一个函数主体的表达式，而表达式表达式的值由新函数返回。

例子 (保存为 `lambda.py`):

~~~python
points = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ]
points.sort(key=lambda i : i['y'])
print(points)
~~~

输出:

~~~
[{'x': 4, 'y': 1}, {'x': 2, 'y': 3}]
~~~

它是如何工作的:

注意，`list`的`sort`方法可以取一个`key`(键)参数，用于确定列表如何排序(通常我们知道只有升序或降序)。在我们的例子中，我们要做一个自定义排序，为此，我们需要编写一个函数，我们只使用一个lambda表达式创建一个新的函数，而不是为只在这一个地方使用的函数写一个单独的`def`块。

## 列表解析 

列表解析用于从现有的列表派生一个新列表。假设您有一个数字列表，你想要得到一个相应的列表：只有当数字本身大于2时所有的数字乘以2，列表解析非常适合这种情况。

例子 (保存为`list_comprehension.py`):

~~~python
listone = [2, 3, 4]
listtwo = [2*i for i in listone if i > 2]
print(listtwo)
~~~

输出:

~~~
$ python3 list_comprehension.py
[6, 8]
~~~

它是如何工作的:

这里，我们在满足一些条件的情况下(`if i > 2`)通过指定的操作(`2*i`)得到一个新列表。注意，原始列表仍未修改。

使用列表解析的优势是：当我们使用循环来处理列表中的每个元素，并将其存储在一个新的列表时，它可以减少需要代码的引用数量。

## 在函数中接受元组和字典

函数有一种特殊的方式接收参数--分别使用*和**前缀标识元组或字典。当函数获取数量可变的参数时这很有用。

~~~
>>> def powersum(power, *args):
...     '''返回每个参数指定次方的和。'''
...     total = 0
...     for i in args:
...         total += pow(i, power)
...     return total
...
>>> powersum(2, 3, 4)
25

>>> powersum(2, 10)
100
~~~

因为我们有一个`*`前缀在`args`变量前，所有额外的传递给函数的参数存储作为元组的`args` 中。如果使用**前缀，额外的参数将被认为是键/值对的字典。

## assert(断言)语句 

`assert`语句是用来声称某样东西是确实的。例如，如果你很确定你将使用的列表中至少有一个元素，而你想检查如果它不是真实的出现一个错误。那么`assert`语句在这种情况下是一个好主意。当断言语句失败，出现一个`AssertionError`(断言错误)。

~~~
>>> mylist = ['条款']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'条款'
>>> mylist
[]
>>> assert len(mylist) >= 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AssertionError
~~~

`assert`语句应该明智而审慎地使用。大多数时候，它能很好地捕捉异常，要么处理问题或向用户显示一条错误消息，然后退出。

## 转义字符

假设,你想有一个包含单引号(`'`)的字符串，你将如何指定该字符串呢？例如，字符串是`What's your name?`，你不能指定为`'What's your name?'`因为Python会对在哪里开始和结束字符串感到困惑。所以，你必须指定这个单引号不表示是字符串的末尾。这可以在叫做*转义字符*的帮助下实现。你将单引号指定为`\'`——注意，反斜杠。现在，您可以指定字符串为`'What\'s your name?'`。

指定这个特定的字符串的另一种方式是`"What's your name?"`，即使用双引号。同样的，在一个双引号的字符串中为双引号本身必须使用一个转义字符。另外，对反斜杠本身要使用转义字符 `\\`。

如果你想指定一个两行的字符串该怎样在做呢？一种方法是使用[前面]](#三重引号) 介绍的三重引号，或者您可以使用新行转义字符--`\n`来表示一个新行开始。一个例子是 `这是第1行\n这是第2行`。另一个要知道的有用的转义字符是制表符 `\t`。有更多的转义字符，但在这我只提到最有用的几个。

需要注意的是，在一个字符串中，在一行结束处的反斜杠表明字符串在下一行仍在继续，并没有换行。例如:

~~~python
"这是第1个句子。\
这是第2个句子。"
~~~

相当于

~~~python
"这是第1个句子。这是第2个句子。"
~~~

### 原始字符串

如果你需要指定没有经过像转义字符一样进行处理的字符串，那么，你需要通过对字符串前加前缀`r`或`R`来指定一个*原始*的字符串。一个例子是 `r"\n表明新行"`。

正则表达式用户需要注意

:   在处理正则表达式时总是使用原始字符串，否则，需要大量的反斜杠。例如，反向引用可以被指向`'\\1'`或`r'\1'`。

## 小结

在这一章，我们讨论了一些Python的更多功能，然而我们还没有覆盖所有Python的特点。然而，,在这个阶段，我们已经覆盖了在实践中你会用到的大部分。对于你开始创造任何程序是足够的。

接下来，我们将讨论如何深入探索Python。